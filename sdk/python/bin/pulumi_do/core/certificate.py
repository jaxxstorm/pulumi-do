# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime
from .. import utilities

class Certificate(pulumi.CustomResource):
    """
    Provides a DigitalOcean Certificate resource that allows you to manage
    certificates for configuring TLS termination in Load Balancers.
    Certificates created with this resource can be referenced in your
    Load Balancer configuration via their ID.
    """
    def __init__(__self__, __name__, __opts__=None, certificate_chain=None, domains=None, leaf_certificate=None, name=None, private_key=None, type=None):
        """Create a Certificate resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if certificate_chain and not isinstance(certificate_chain, basestring):
            raise TypeError('Expected property certificate_chain to be a basestring')
        __self__.certificate_chain = certificate_chain
        """
        The full PEM-formatted trust chain
        between the certificate authority's certificate and your domain's TLS
        certificate.
        """
        __props__['certificateChain'] = certificate_chain

        if domains and not isinstance(domains, list):
            raise TypeError('Expected property domains to be a list')
        __self__.domains = domains
        __props__['domains'] = domains

        if leaf_certificate and not isinstance(leaf_certificate, basestring):
            raise TypeError('Expected property leaf_certificate to be a basestring')
        __self__.leaf_certificate = leaf_certificate
        """
        The contents of a PEM-formatted public
        TLS certificate.
        """
        __props__['leafCertificate'] = leaf_certificate

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The name of the certificate for identification.
        """
        __props__['name'] = name

        if private_key and not isinstance(private_key, basestring):
            raise TypeError('Expected property private_key to be a basestring')
        __self__.private_key = private_key
        """
        The contents of a PEM-formatted private-key
        corresponding to the SSL certificate.
        """
        __props__['privateKey'] = private_key

        if type and not isinstance(type, basestring):
            raise TypeError('Expected property type to be a basestring')
        __self__.type = type
        __props__['type'] = type

        __self__.not_after = pulumi.runtime.UNKNOWN
        """
        The expiration date of the certificate
        """
        __self__.sha1_fingerprint = pulumi.runtime.UNKNOWN
        """
        The SHA-1 fingerprint of the certificate
        """
        __self__.state = pulumi.runtime.UNKNOWN

        super(Certificate, __self__).__init__(
            'do:core/certificate:Certificate',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'certificateChain' in outs:
            self.certificate_chain = outs['certificateChain']
        if 'domains' in outs:
            self.domains = outs['domains']
        if 'leafCertificate' in outs:
            self.leaf_certificate = outs['leafCertificate']
        if 'name' in outs:
            self.name = outs['name']
        if 'notAfter' in outs:
            self.not_after = outs['notAfter']
        if 'privateKey' in outs:
            self.private_key = outs['privateKey']
        if 'sha1Fingerprint' in outs:
            self.sha1_fingerprint = outs['sha1Fingerprint']
        if 'state' in outs:
            self.state = outs['state']
        if 'type' in outs:
            self.type = outs['type']
