# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime
from .. import utilities

class LoadBalancer(pulumi.CustomResource):
    """
    Provides a DigitalOcean Load Balancer resource. This can be used to create,
    modify, and delete Load Balancers.
    """
    def __init__(__self__, __name__, __opts__=None, algorithm=None, droplet_ids=None, droplet_tag=None, forwarding_rules=None, healthcheck=None, name=None, redirect_http_to_https=None, region=None, sticky_sessions=None):
        """Create a LoadBalancer resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if algorithm and not isinstance(algorithm, basestring):
            raise TypeError('Expected property algorithm to be a basestring')
        __self__.algorithm = algorithm
        """
        The load balancing algorithm used to determine
        which backend Droplet will be selected by a client. It must be either `round_robin`
        or `least_connections`. The default value is `round_robin`.
        """
        __props__['algorithm'] = algorithm

        if droplet_ids and not isinstance(droplet_ids, list):
            raise TypeError('Expected property droplet_ids to be a list')
        __self__.droplet_ids = droplet_ids
        """
        A list of the IDs of each droplet to be attached to the Load Balancer.
        """
        __props__['dropletIds'] = droplet_ids

        if droplet_tag and not isinstance(droplet_tag, basestring):
            raise TypeError('Expected property droplet_tag to be a basestring')
        __self__.droplet_tag = droplet_tag
        """
        The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
        """
        __props__['dropletTag'] = droplet_tag

        if not forwarding_rules:
            raise TypeError('Missing required property forwarding_rules')
        elif not isinstance(forwarding_rules, list):
            raise TypeError('Expected property forwarding_rules to be a list')
        __self__.forwarding_rules = forwarding_rules
        """
        A list of `forwarding_rule` to be assigned to the
        Load Balancer. The `forwarding_rule` block is documented below.
        """
        __props__['forwardingRules'] = forwarding_rules

        if healthcheck and not isinstance(healthcheck, dict):
            raise TypeError('Expected property healthcheck to be a dict')
        __self__.healthcheck = healthcheck
        """
        A `healthcheck` block to be assigned to the
        Load Balancer. The `healthcheck` block is documented below. Only 1 healthcheck is allowed.
        """
        __props__['healthcheck'] = healthcheck

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The Load Balancer name
        """
        __props__['name'] = name

        if redirect_http_to_https and not isinstance(redirect_http_to_https, bool):
            raise TypeError('Expected property redirect_http_to_https to be a bool')
        __self__.redirect_http_to_https = redirect_http_to_https
        """
        A boolean value indicating whether
        HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
        Default value is `false`.
        """
        __props__['redirectHttpToHttps'] = redirect_http_to_https

        if not region:
            raise TypeError('Missing required property region')
        elif not isinstance(region, basestring):
            raise TypeError('Expected property region to be a basestring')
        __self__.region = region
        """
        The region to start in
        """
        __props__['region'] = region

        if sticky_sessions and not isinstance(sticky_sessions, dict):
            raise TypeError('Expected property sticky_sessions to be a dict')
        __self__.sticky_sessions = sticky_sessions
        """
        A `sticky_sessions` block to be assigned to the
        Load Balancer. The `sticky_sessions` block is documented below. Only 1 sticky_sessions block is allowed.
        """
        __props__['stickySessions'] = sticky_sessions

        __self__.ip = pulumi.runtime.UNKNOWN
        __self__.status = pulumi.runtime.UNKNOWN

        super(LoadBalancer, __self__).__init__(
            'do:core/loadBalancer:LoadBalancer',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'algorithm' in outs:
            self.algorithm = outs['algorithm']
        if 'dropletIds' in outs:
            self.droplet_ids = outs['dropletIds']
        if 'dropletTag' in outs:
            self.droplet_tag = outs['dropletTag']
        if 'forwardingRules' in outs:
            self.forwarding_rules = outs['forwardingRules']
        if 'healthcheck' in outs:
            self.healthcheck = outs['healthcheck']
        if 'ip' in outs:
            self.ip = outs['ip']
        if 'name' in outs:
            self.name = outs['name']
        if 'redirectHttpToHttps' in outs:
            self.redirect_http_to_https = outs['redirectHttpToHttps']
        if 'region' in outs:
            self.region = outs['region']
        if 'status' in outs:
            self.status = outs['status']
        if 'stickySessions' in outs:
            self.sticky_sessions = outs['stickySessions']
