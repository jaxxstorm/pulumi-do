"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const debuggable_1 = require("./debuggable");
const grpc = require("grpc");
const engrpc = require("../proto/engine_grpc_pb.js");
const resrpc = require("../proto/resource_grpc_pb.js");
/**
 * excessiveDebugOutput enables, well, pretty excessive debug output pertaining to resources and properties.
 */
exports.excessiveDebugOutput = false;
/**
 * _options are the current deployment options being used for this entire session.
 */
const options = loadOptions();
/**
 * Returns true if we're currently performing a dry-run, or false if this is a true update.
 */
function isDryRun() {
    return options.dryRun === true;
}
exports.isDryRun = isDryRun;
/**
 * Get the project being run by the current update.
 */
function getProject() {
    return options.project;
}
exports.getProject = getProject;
/**
 * Get the stack being targeted by the current update.
 */
function getStack() {
    return options.stack;
}
exports.getStack = getStack;
/**
 * monitor is a live connection to the resource monitor that tracks deployments (lazily initialized).
 */
let monitor;
/**
 * hasMonitor returns true if we are currently connected to a resource monitoring service.
 */
function hasMonitor() {
    return !!monitor && !!options.monitorAddr;
}
exports.hasMonitor = hasMonitor;
/**
 * getMonitor returns the current resource monitoring service client for RPC communications.
 */
function getMonitor() {
    if (!monitor) {
        const addr = options.monitorAddr;
        if (addr) {
            // Lazily initialize the RPC connection to the monitor.
            monitor = new resrpc.ResourceMonitorClient(addr, grpc.credentials.createInsecure());
        }
        else {
            // Otherwise, this is an error.
            throw new errors_1.RunError("Pulumi program not connected to the engine -- are you running with the `pulumi` CLI?");
        }
    }
    return monitor;
}
exports.getMonitor = getMonitor;
/**
 * engine is a live connection to the engine, used for logging, etc. (lazily initialized).
 */
let engine;
/**
 * getEngine returns the current engine, if any, for RPC communications back to the resource engine.
 */
function getEngine() {
    if (!engine) {
        const addr = options.engineAddr;
        if (addr) {
            // Lazily initialize the RPC connection to the engine.
            engine = new engrpc.EngineClient(addr, grpc.credentials.createInsecure());
        }
    }
    return engine;
}
exports.getEngine = getEngine;
/**
 * serialize returns true if resource operations should be serialized.
 */
function serialize() {
    const p = options.parallel;
    return !p || p <= 1;
}
exports.serialize = serialize;
/**
 * loadOptions recovers the options from the environment, which is set before we begin executing. This ensures
 * that even when multiple copies of this module are loaded, they all get the same values.
 */
function loadOptions() {
    // The only option that needs parsing is the parallelism flag.  Ignore any failures.
    let parallel;
    const parallelOpt = process.env["PULUMI_NODEJS_PARALLEL"];
    if (parallelOpt) {
        try {
            parallel = parseInt(parallelOpt, 10);
        }
        catch (err) {
            // ignore.
        }
    }
    // Now just hydrate the rest from environment variables.  These might be missing, in which case
    // we will fail later on when we actually need to create an RPC connection back to the engine.
    return {
        project: process.env["PULUMI_NODEJS_PROJECT"],
        stack: process.env["PULUMI_NODEJS_STACK"],
        dryRun: (process.env["PULUMI_NODEJS_DRY_RUN"] === "true"),
        parallel: parallel,
        monitorAddr: process.env["PULUMI_NODEJS_MONITOR"],
        engineAddr: process.env["PULUMI_NODEJS_ENGINE"],
    };
}
/**
 * disconnect permanently disconnects from the server, closing the connections.  It waits for the existing RPC
 * queue to drain.  If any RPCs come in afterwards, however, they will crash the process.
 */
function disconnect() {
    let done;
    const closeCallback = () => {
        if (done !== rpcDone) {
            // If the done promise has changed, some activity occurred in between callbacks.  Wait again.
            done = rpcDone;
            return debuggable_1.debuggablePromise(done.then(closeCallback));
        }
        disconnectSync();
        return Promise.resolve();
    };
    closeCallback();
}
exports.disconnect = disconnect;
/**
 * disconnectSync permanently disconnects from the server, closing the connections. Unlike `disconnect`. it does not
 * wait for the existing RPC queue to drain. Any RPCs that come in after this call will crash the process.
 */
function disconnectSync() {
    // Otherwise, actually perform the close activities (ignoring errors and crashes).
    if (monitor) {
        try {
            monitor.close();
        }
        catch (err) {
            // ignore.
        }
        monitor = null;
    }
    if (engine) {
        try {
            engine.close();
        }
        catch (err) {
            // ignore.
        }
        engine = null;
    }
}
exports.disconnectSync = disconnectSync;
/**
 * rpcDone resolves when the last known client-side RPC call finishes.
 */
let rpcDone = Promise.resolve();
/**
 * rpcKeepAlive registers a pending call to ensure that we don't prematurely disconnect from the server.  It returns
 * a function that, when invoked, signals that the RPC has completed.
 */
function rpcKeepAlive() {
    let done = undefined;
    const donePromise = debuggable_1.debuggablePromise(new Promise((resolve) => { done = resolve; }));
    rpcDone = rpcDone.then(() => donePromise);
    return done;
}
exports.rpcKeepAlive = rpcKeepAlive;
let rootResource;
/**
 * getRootResource returns a root resource that will automatically become the default parent of all resources.  This
 * can be used to ensure that all resources without explicit parents are parented to a common parent resource.
 */
function getRootResource() {
    return rootResource;
}
exports.getRootResource = getRootResource;
/**
 * setRootResource registers a resource that will become the default parent for all resources without explicit parents.
 */
function setRootResource(res) {
    if (rootResource && res) {
        throw new Error("Cannot set multiple root resources");
    }
    rootResource = res;
}
exports.setRootResource = setRootResource;
