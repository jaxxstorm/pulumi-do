"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const runtime = require("./runtime");
const resource_1 = require("./runtime/resource");
const settings_1 = require("./runtime/settings");
/**
 * Resource represents a class whose CRUD operations are implemented by a provider plugin.
 */
class Resource {
    /**
     * Creates and registers a new resource object.  t is the fully qualified type token and name is
     * the "name" part to use in creating a stable and globally unique URN for the object.
     * dependsOn is an optional list of other resources that this resource depends on, controlling
     * the order in which we perform resource operations.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param custom True to indicate that this is a custom resource, managed by a plugin.
     * @param props The arguments to use to populate the new resource.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(t, name, custom, props = {}, opts = {}) {
        /**
         * A private field to help with RTTI that works in SxS scenarios.
         */
        // tslint:disable-next-line:variable-name
        /* @internal */ this.__pulumiResource = true;
        if (!t) {
            throw new errors_1.RunError("Missing resource type argument");
        }
        if (!name) {
            throw new errors_1.RunError("Missing resource name argument (for URN creation)");
        }
        // If there wasn't an explicit parent, and a root resource exists, parent to that.
        if (!opts.parent) {
            opts.parent = settings_1.getRootResource();
        }
        // Check the parent type and fill in any default options.
        this.__providers = {};
        if (opts.parent) {
            if (!Resource.isInstance(opts.parent)) {
                throw new errors_1.RunError(`Resource parent is not a valid Resource: ${opts.parent}`);
            }
            if (opts.protect === undefined) {
                opts.protect = opts.parent.__protect;
            }
            this.__providers = opts.parent.__providers;
            if (custom) {
                const provider = opts.provider;
                if (provider === undefined) {
                    opts.provider = opts.parent.getProvider(t);
                }
            }
        }
        if (!custom) {
            const providers = opts.providers;
            if (providers) {
                this.__providers = Object.assign({}, this.__providers, providers);
            }
        }
        this.__protect = !!opts.protect;
        if (opts.id) {
            // If this resource already exists, read its state rather than registering it anew.
            if (!custom) {
                throw new errors_1.RunError("Cannot read an existing resource unless it has a custom provider");
            }
            resource_1.readResource(this, t, name, props, opts);
        }
        else {
            // Kick off the resource registration.  If we are actually performing a deployment, this
            // resource's properties will be resolved asynchronously after the operation completes, so
            // that dependent computations resolve normally.  If we are just planning, on the other
            // hand, values will never resolve.
            resource_1.registerResource(this, t, name, custom, props, opts);
        }
    }
    static isInstance(obj) {
        return obj && obj.__pulumiResource;
    }
    // getProvider fetches the provider for the given module member, if any.
    getProvider(moduleMember) {
        const memComponents = moduleMember.split(":");
        if (memComponents.length !== 3) {
            return undefined;
        }
        const pkg = memComponents[0];
        return this.__providers[pkg];
    }
}
exports.Resource = Resource;
Resource.doNotCapture = true;
/**
 * CustomResource is a resource whose create, read, update, and delete (CRUD) operations are managed
 * by performing external operations on some physical entity.  The engine understands how to diff
 * and perform partial updates of them, and these CRUD operations are implemented in a dynamically
 * loaded plugin for the defining package.
 */
class CustomResource extends Resource {
    /**
     * Creates and registers a new managed resource.  t is the fully qualified type token and name
     * is the "name" part to use in creating a stable and globally unique URN for the object.
     * dependsOn is an optional list of other resources that this resource depends on, controlling
     * the order in which we perform resource operations. Creating an instance does not necessarily
     * perform a create on the physical entity which it represents, and instead, this is dependent
     * upon the diffing of the new goal state compared to the current known resource state.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param props The arguments to use to populate the new resource.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(t, name, props, opts) {
        super(t, name, true, props, opts);
        /**
         * A private field to help with RTTI that works in SxS scenarios.
         */
        // tslint:disable-next-line:variable-name
        /* @internal */ this.__pulumiCustomResource = true;
    }
    /**
     * Returns true if the given object is an instance of CustomResource.  This is designed to work even when
     * multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        return obj && obj.__pulumiCustomResource;
    }
}
exports.CustomResource = CustomResource;
CustomResource.doNotCapture = true;
/**
 * ProviderResource is a resource that implements CRUD operations for other custom resources. These resources are
 * managed similarly to other resources, including the usual diffing and update semantics.
 */
class ProviderResource extends CustomResource {
    /**
     * Creates and registers a new provider resource for a particular package.
     *
     * @param pkg The package associated with this provider.
     * @param name The _unique_ name of the provider.
     * @param props The configuration to use for this provider.
     * @param opts A bag of options that control this provider's behavior.
     */
    constructor(pkg, name, props, opts) {
        if (opts && opts.provider !== undefined) {
            throw new errors_1.RunError("Explicit providers may not be used with provider resources");
        }
        super(`pulumi:providers:${pkg}`, name, props, opts);
    }
}
exports.ProviderResource = ProviderResource;
/**
 * ComponentResource is a resource that aggregates one or more other child resources into a higher
 * level abstraction. The component resource itself is a resource, but does not require custom CRUD
 * operations for provisioning.
 */
class ComponentResource extends Resource {
    /**
     * Creates and registers a new component resource.  t is the fully qualified type token and name
     * is the "name" part to use in creating a stable and globally unique URN for the object. parent
     * is the optional parent for this component, and dependsOn is an optional list of other
     * resources that this resource depends on, controlling the order in which we perform resource
     * operations.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param props The arguments to use to populate the new resource.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(t, name, props, opts) {
        if (opts && opts.provider !== undefined) {
            throw new errors_1.RunError("Explicit providers may not be used with component resources");
        }
        super(t, name, false, props, opts);
    }
    // registerOutputs registers synthetic outputs that a component has initialized, usually by allocating
    // other child sub-resources and propagating their resulting property values.
    registerOutputs(outputs) {
        if (outputs) {
            resource_1.registerResourceOutputs(this, outputs);
        }
    }
}
exports.ComponentResource = ComponentResource;
ComponentResource.doNotCapture = true;
ComponentResource.prototype.registerOutputs.doNotCapture = true;
/**
 * Output helps encode the relationship between Resources in a Pulumi application. Specifically an
 * Output holds onto a piece of Data and the Resource it was generated from. An Output value can
 * then be provided when constructing new Resources, allowing that new Resource to know both the
 * value as well as the Resource the value came from.  This allows for a precise 'Resource
 * dependency graph' to be created, which properly tracks the relationship between resources.
 */
class Output {
    /* @internal */ constructor(resources, promise, isKnown) {
        /**
         * A private field to help with RTTI that works in SxS scenarios.
         *
         * This is internal instead of being truly private, to support mixins and our serialization model.
         */
        // tslint:disable-next-line:variable-name
        /* @internal */ this.__pulumiOutput = true;
        this.isKnown = isKnown;
        // Always create a copy so that no one accidentally modifies our Resource list.
        this.resources = () => new Set(resources);
        this.promise = () => promise;
        this.apply = (func) => {
            return new Output(resources, promise.then((v) => __awaiter(this, void 0, void 0, function* () {
                // During previews do not perform the apply if the engine was not able to
                // give us an actual value for this Output.
                const perform = yield isKnown;
                if (runtime.isDryRun() && !perform) {
                    return undefined;
                }
                const transformed = yield func(v);
                if (Output.isInstance(transformed)) {
                    // Note: if the func returned a Output, we unwrap that to get the inner value
                    // returned by that Output.  Note that we are *not* capturing the Resources of
                    // this inner Output.  That's intentional.  As the Output returned is only
                    // supposed to be related this *this* Output object, those resources should
                    // already be in our transitively reachable resource graph.
                    return yield transformed.promise();
                }
                else {
                    return transformed;
                }
            })), isKnown);
        };
        this.get = () => {
            throw new errors_1.RunError(`Cannot call '.get' during update or preview.
To manipulate the value of this Output, use '.apply' instead.`);
        };
    }
    // Statics
    /**
     * Returns true if the given object is an instance of Output<T>.  This is designed to work even when
     * multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        return obj && obj.__pulumiOutput;
    }
    /* @internal */ static create(resource, promise, isKnown) {
        return new Output(new Set([resource]), promise, isKnown);
    }
}
exports.Output = Output;
function output(cv) {
    // outputs created from simply inputs are always stable.
    return Output.isInstance(cv) ? cv :
        new Output(new Set(), Promise.resolve(cv), Promise.resolve(true));
}
exports.output = output;
function all(val) {
    if (val instanceof Array) {
        const allOutputs = val.map(v => output(v));
        const resources = allOutputs.reduce((arr, o) => (arr.push(...o.resources()), arr), []);
        const promises = allOutputs.map(o => o.promise());
        // A merged output is known if all of its inputs are known.
        const isKnown = Promise.all(allOutputs.map(o => o.isKnown)).then(ps => ps.every(b => b));
        return new Output(new Set(resources), Promise.all(promises), isKnown);
    }
    else {
        const array = Object.keys(val).map(k => output(val[k]).apply(v => ({ key: k, value: v })));
        return all(array).apply(keysAndValues => {
            const result = {};
            for (const kvp of keysAndValues) {
                result[kvp.key] = kvp.value;
            }
            return result;
        });
    }
}
exports.all = all;
